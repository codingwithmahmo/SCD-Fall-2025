from datetime import datetime
from typing import List, Optional


# =========================
# Base class: User
# =========================

class User:
    """
    User is the base class for all system users (Student, Teacher, Admin).
    It holds common identity information and generic authentication behavior.
    """

    def __init__(self, user_id: int, name: str, email: str, password: str):
        # Unique identifier for the user (e.g., database primary key)
        self.user_id = user_id

        # Human-readable name for the user
        self.name = name

        # Contact email used for login and notifications
        self.email = email

        # Password (in a real system this should be hashed, not plain text)
        self.password = password

    def login(self, email: str, password: str) -> bool:
        """
        Simulates a login process by matching the given credentials
        with the stored email and password.
        """
        # Check if email and password match the stored values
        if self.email == email and self.password == password:
            # If they match, login is considered successful
            return True
        # Otherwise, login fails
        return False

    def recover_password(self, email: str) -> bool:
        """
        Simulates password recovery by checking if the provided email
        matches the user's email. In reality, this would trigger an
        email with reset instructions.
        """
        # Only allow recovery if the email matches the registered one
        if self.email == email:
            # Recovery process would be initiated here (e.g., send email)
            return True
        # If email doesn't match, recovery is not allowed
        return False


# =========================
# Supporting classes
# =========================

class Attendance:
    """
    Attendance represents a single attendance record for a student
    on a specific date with a given status (Present/Absent).
    """

    def __init__(self, attendance_id: int, student_id: int, date: datetime, status: str):
        # Unique identifier for this particular attendance entry
        self.attendance_id = attendance_id

        # ID of the student this attendance belongs to
        self.student_id = student_id

        # Date on which attendance was marked
        self.date = date

        # Status of attendance (e.g., "Present", "Absent", "Late")
        self.status = status

    def record_attendance(self) -> bool:
        """
        Simulates saving this attendance record.
        Normally, this would persist to a database.
        """
        # Here we'd have logic to save to a database.
        # For now, we simply return True to indicate success.
        return True


class Notification:
    """
    Notification represents a message that can be sent to users,
    usually generated by an Admin or the system.
    """

    def __init__(self, notification_id: int, message: str, date_issued: datetime):
        # Unique identifier for the notification
        self.notification_id = notification_id

        # The actual content/message of the notification
        self.message = message

        # Date and time when the notification was created/issued
        self.date_issued = date_issued

    def send_notification(self, recipient: User) -> bool:
        """
        Simulates sending a notification to a specific user.
        """
        # In reality, this could send an email, SMS, or in-app notification.
        # Here, we simply pretend it succeeded.
        # You could print or log something if needed.
        return True


class Report:
    """
    Report represents a generic report generated in the system,
    such as attendance reports, performance reports, etc.
    """

    def __init__(self, report_id: int, report_type: str, generated_date: datetime, content: str):
        # Unique identifier for this report
        self.report_id = report_id

        # Type/category of the report (e.g., "Attendance", "Performance")
        self.report_type = report_type

        # Date and time when the report was generated
        self.generated_date = generated_date

        # The actual data or summary of the report
        self.content = content

    def save_report(self) -> bool:
        """
        Simulates saving the report for later viewing or export.
        """
        # Real implementation would persist the report (e.g., store as PDF or in database)
        return True


class Schedule:
    """
    Schedule represents a single schedule entry for a course or class,
    including the time slot and course name.
    """

    def __init__(self, schedule_id: int, course_name: str, time_slot: str):
        # Unique identifier for this schedule entry
        self.schedule_id = schedule_id

        # Name of the course (e.g., "Math 101")
        self.course_name = course_name

        # Time slot description (e.g., "Mon 9:00-10:00")
        self.time_slot = time_slot

    def save_schedule(self) -> bool:
        """
        Simulates saving the schedule to the system.
        """
        # Real logic would persist to database or scheduling service
        return True


# =========================
# Derived classes: Student, Teacher, Admin
# =========================

class Student(User):
    """
    Student is a specialized type of User with student-specific
    behavior and attributes.
    """

    def __init__(self, user_id: int, name: str, email: str, password: str,
                 roll_number: str, grade: str, section: str):
        # Initialize common user fields using the base class constructor
        super().__init__(user_id, name, email, password)

        # Unique roll number assigned by the institution
        self.roll_number = roll_number

        # Grade or class (e.g., "10th", "BS-SE 5th semester")
        self.grade = grade

        # Section or group (e.g., "A", "B")
        self.section = section

        # List to hold notifications received by this student
        self.notifications: List[Notification] = []

        # List to hold reports that belong to this student
        self.reports: List[Report] = []

        # List to hold attendance records for this student
        self.attendance_records: List[Attendance] = []

    def view_dashboard(self) -> None:
        """
        Simulates viewing the student dashboard.
        This could include attendance summary, upcoming exams, etc.
        """
        # In a real implementation, data aggregation and UI rendering would happen here.
        pass  # 'pass' means "do nothing for now"

    def mark_attendance(self, present: bool) -> bool:
        """
        Allows a student to mark their own attendance (e.g., in online classes).
        Creates a new Attendance record with the current date and status.
        """
        # Decide status string based on the boolean argument
        status = "Present" if present else "Absent"

        # Generate a new attendance ID (in a real system, DB would handle this)
        new_id = len(self.attendance_records) + 1

        # Create a new attendance object for today
        attendance = Attendance(
            attendance_id=new_id,
            student_id=self.user_id,
            date=datetime.now(),
            status=status
        )

        # Try to record the attendance (e.g., save to DB)
        if attendance.record_attendance():
            # If recording was successful, append to student's local list
            self.attendance_records.append(attendance)
            return True

        # If recording failed, return False
        return False

    def receive_alerts(self) -> List[Notification]:
        """
        Returns the list of notifications assigned to this student.
        This simulates a student viewing their notifications.
        """
        # Simply return the in-memory list of notifications
        return self.notifications

    def submit_leave_application(self, reason: str, from_date: datetime, to_date: datetime) -> bool:
        """
        Simulates submitting a leave application.
        In a real system, this would create a leave request entity.
        """
        # Here, we just simulate by returning True,
        # assuming the application has been submitted successfully.
        # 'reason', 'from_date', and 'to_date' could be stored or processed.
        return True

    def add_notification(self, notification: Notification) -> None:
        """
        Helper method to attach a new notification to this student.
        Typically called by Admin when issuing notifications.
        """
        self.notifications.append(notification)

    def add_report(self, report: Report) -> None:
        """
        Helper method to attach a new report to this student
        (e.g., performance or attendance report).
        """
        self.reports.append(report)


class Teacher(User):
    """
    Teacher is a specialized User responsible for teaching students,
    marking attendance, and generating reports.
    """

    def __init__(self, user_id: int, name: str, email: str, password: str,
                 teacher_id: str, subject: str, designation: str):
        # Call the base User constructor for common fields
        super().__init__(user_id, name, email, password)

        # Unique identifier for the teacher provided by the institution
        self.teacher_id = teacher_id

        # Subject taught by this teacher (e.g., "Math", "Software Engineering")
        self.subject = subject

        # Designation (e.g., "Lecturer", "Assistant Professor")
        self.designation = designation

        # Internal list of schedules created by this teacher
        self.schedules: List[Schedule] = []

    def create_schedule(self, schedule_id: int, course_name: str, time_slot: str) -> Schedule:
        """
        Creates a new schedule entry for a course and saves it.
        """
        # Create a schedule instance with given details
        schedule = Schedule(schedule_id, course_name, time_slot)

        # Persist the schedule (simulated via save_schedule())
        if schedule.save_schedule():
            # If saved successfully, track it in teacher's schedules list
            self.schedules.append(schedule)

        # Return the created schedule object (even if save failed in this simple example)
        return schedule

    def mark_attendance(self, student: Student, present: bool) -> bool:
        """
        Teacher marks attendance for a specific student.
        Internally, this creates an Attendance entry for that student.
        """
        # Decide status based on boolean
        status = "Present" if present else "Absent"

        # Generate a new attendance ID based on current count
        new_id = len(student.attendance_records) + 1

        # Create the attendance object
        attendance = Attendance(
            attendance_id=new_id,
            student_id=student.user_id,
            date=datetime.now(),
            status=status
        )

        # Try to record the attendance
        if attendance.record_attendance():
            # If successful, attach to student's attendance records
            student.attendance_records.append(attendance)
            return True

        # If record operation fails, return False
        return False

    def generate_report(self, student: Student, report_type: str) -> Report:
        """
        Teacher generates a report for a specific student.
        For simplicity, we create a basic text-based report.
        """
        # Auto-generate an ID based on number of reports student already has
        report_id = len(student.reports) + 1

        # Basic content example; in real life this would be more detailed and data-driven
        content = f"Report for {student.name} ({student.roll_number}), Type: {report_type}"

        # Create report object with current timestamp
        report = Report(
            report_id=report_id,
            report_type=report_type,
            generated_date=datetime.now(),
            content=content
        )

        # Save report (simulate persistence)
        report.save_report()

        # Attach report to the student record for later viewing
        student.add_report(report)

        # Return the newly created report object
        return report

    def flag_low_attendance(self, student: Student, threshold_percentage: float) -> bool:
        """
        Flags a student if their attendance is below a given threshold.
        Returns True if flagged, False otherwise.
        """
        # If student has no attendance records yet, we cannot calculate a percentage
        total = len(student.attendance_records)
        if total == 0:
            return False

        # Count how many records are marked "Present"
        presents = sum(
            1 for record in student.attendance_records if record.status == "Present"
        )

        # Calculate attendance percentage
        percentage = (presents / total) * 100.0

        # Check if the attendance is below the threshold
        if percentage < threshold_percentage:
            # In a real system, we might notify admin, or add a flag in DB.
            return True

        # Otherwise, no flag is raised
        return False


class Admin(User):
    """
    Admin is a specialized User with higher-level permissions
    to manage users, configuration, and system-wide notifications.
    """

    def __init__(self, user_id: int, name: str, email: str, password: str,
                 admin_id: str, role: str):
        # Initialize common user fields
        super().__init__(user_id, name, email, password)

        # Unique identifier for the admin
        self.admin_id = admin_id

        # Role of the admin (e.g., "System Admin", "Registrar")
        self.role = role

        # Internal list to simulate a user database
        self.managed_users: List[User] = []

    def add_user(self, user: User) -> bool:
        """
        Adds a new user to the system's managed user list.
        """
        # Check if user is already in the list based on user_id
        if any(u.user_id == user.user_id for u in self.managed_users):
            # If user already exists, we don't add again
            return False

        # Otherwise, append user to the list
        self.managed_users.append(user)
        return True

    def remove_user(self, user_id: int) -> bool:
        """
        Removes a user from the system based on their user_id.
        """
        # Iterate over managed_users to find a matching user
        for user in self.managed_users:
            if user.user_id == user_id:
                # If found, remove from the list and return success
                self.managed_users.remove(user)
                return True

        # If no matching user found, return False
        return False

    def edit_permissions(self, user_id: int, new_role: str) -> bool:
        """
        Simulates editing user permissions. In a real system this might
        involve role-based access controls. Here we just demonstrate
        conceptually with Admin only.
        """
        # For simplicity, let's assume only Admin objects have 'role' we can edit
        for user in self.managed_users:
            if isinstance(user, Admin) and user.user_id == user_id:
                # Update the role of the admin
                user.role = new_role
                return True
        return False

    def export_report(self, report: Report) -> str:
        """
        Simulates exporting a report to a file.
        Instead of handling actual files, we return a file path as string.
        """
        # Generate a fake file path using the report ID
        file_path = f"/exports/report_{report.report_id}.pdf"

        # In a real implementation, we would generate a PDF and save it at file_path.
        # Returning the path indicates where the file would be.
        return file_path

    def configure_settings(self, setting_name: str, value) -> bool:
        """
        Simulates changing a system-wide configuration setting.
        """
        # In reality, this would update some configuration store or database
        # Here we simply accept and return True to indicate it "worked".
        return True

    def issue_notifications(self, users: List[User], message: str) -> int:
        """
        Issues a notification with the given message to a list of users.
        Returns the count of notifications successfully sent.
        """
        # Create a single Notification object representing this broadcast
        notification = Notification(
            notification_id=1,  # Normally generated by DB or sequence
            message=message,
            date_issued=datetime.now()
        )

        sent_count = 0

        # Send the notification to each user
        for user in users:
            # Perform the send operation (simulated method)
            if notification.send_notification(user):
                sent_count += 1

                # If the user is a Student, also store it in their notification list
                if isinstance(user, Student):
                    user.add_notification(notification)

        # Return how many notifications were "sent"
        return sent_count


# =========================
# Example usage (for understanding)
# =========================

if __name__ == "__main__":
    # Create an admin
    admin = Admin(
        user_id=1,
        name="System Admin",
        email="admin@school.com",
        password="admin123",
        admin_id="ADM001",
        role="System Admin"
    )

    # Create a teacher
    teacher = Teacher(
        user_id=2,
        name="Ali Khan",
        email="ali.khan@school.com",
        password="teach123",
        teacher_id="T001",
        subject="Software Engineering",
        designation="Lecturer"
    )

    # Create a student
    student = Student(
        user_id=3,
        name="Mahmood",
        email="mahmood@student.com",
        password="stud123",
        roll_number="RSE-56067",
        grade="5th Semester",
        section="A"
    )

    # Admin adds users to system
    admin.add_user(teacher)
    admin.add_user(student)

    # Teacher creates a schedule
    schedule = teacher.create_schedule(
        schedule_id=1,
        course_name="Software Design & Architecture",
        time_slot="Mon 10:00 - 12:00"
    )
    
    print("✅ Schedule created:", schedule.course_name, schedule.time_slot)

    # Teacher marks student's attendance
    attendance_success = teacher.mark_attendance(student, present=True)
    print("✅ Attendance marked:", attendance_success)

    # Teacher generates a report
    report = teacher.generate_report(student, report_type="Attendance")
    print("✅ Report generated:", report.report_type, report.generated_date)

    # Admin exports the report
    export_path = admin.export_report(report)
    print("✅ Report exported to:", export_path)

    # Admin sends notifications
    total_sent = admin.issue_notifications(
        users=admin.managed_users,
        message="Midterm exams schedule has been uploaded."
    )
    print("✅ Notifications sent:", total_sent)
